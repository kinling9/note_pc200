# 现代微处理器：指令级并行
## 高速缓存（Cache）
### cache设计的4个问题
1. 写入
  - 直写:
  同时向cache和低一级存储器写入数据
  - 写回:
  只往cache中写入，**dirty**指标来指导主存写入
2. cache预取:
预先准备cache内容来加速程序的运行
  - 硬件预取，一般根据连续的数据读取取连续的单元
  - 软件预取，预取相关指令，可以由开发者指定cache读取内容

### cache实例
  - x86 架构
    - cache层数相对复杂
    - 储存更多的数据
    - 命中过程耗时更长
  - arm 架构
    - cache相对简单
    - 读写速度与cpu执行速度相同
    - 对应组相联数更小
  - 指令与数据分离(哈佛结构)
    - 指令只用来指明选择数据的地址
    - 通过cache或者外部存储机构去取得需要进行运算的数据内容

### 提高命中率的软件优化
- ！减少在硬件预取过程中的反复数据读写过程
- 手动预测分块，保证cache中可以对对应的数据进行维护，


## 流水线基础
### CISC vs RISC
  - CSIC简单指令（e.g. 加减乘除）也能访存，RSIC需专门指令才能访问内存，因此提供大量寄存器
  - CSIC：intel x86（历史原因）必须兼容前一代cpu
  - CSIC内部微程序机制（拆解指令）是基于RSIC
### 流水线的实现
1. MIPS数据通路+流水线
  - 插入数据传输寄存器，切分关键路径（ALU）->缩短长度
### 流水线冒险
  1. 结构
  - 指令/数据存储器端口共用
  - 解决
    - 增加硬件
    - L1 cache 分离
  2. 数据
  - 需要的数据还未准备好
  - 解决：
    - 流水线停顿（代价很高）
    - 转发：创造数据旁路（EX/MEM->ALU）
  3. 控制/分支
  - 解决：
    - 冻结
    - 预测:
    两位预测状态机，根据最近2次分支行为预测
    - 延迟:
    早期RISC策略

## 高级流水线技术
### 动态调度
- 主要思想
: 顺序执行时，一条指令的停顿，后面不相关指令收到影响
- 相关-冒险：
  - 真·数据相关 -RAW
  - 输出相关 - WAW
  - 反相关 - WAR

#### Tomasulo算法（状态存储）
- 使用**保留站**和重命名(源操作数的值)
- 针对WAR和WAW
- 指令顺序读入，还是卡顿
- 步骤
  1. 发射 Issue
  2. 执行 Execute
  3. 写结果 Write result

#### 投机
- 控制相关，假定分支预测正确
- 步骤
  1. 发射 Issue
  2. 执行 Execute
  3. 写结果 Write result
  4. **指令提交** Commit:
    - 暂存不确定性指令执行结果至**重排序缓冲区（ROB）**，确定后再更新对应存储/寄存

#### 多发射
- 一个时钟周期，向多个不同功能单元发射指令
- 4类功能单元
  1. 存储器访问
  2. 浮点乘
  3. 浮点加
  4. 整数运算
- ！发射逻辑复杂度

#### 多线程（单核）
- 以重叠的方式共享单个处理器的功能单元
- 同时多线程（SMT）
  - 动态调度+多发射

## 多核处理器

## 实例分析
### ARM Cortex-A53
- 简单乱序执行

### Intel Core i7
- 多发射
- 保留站 Tomasulo
- 2线程SMT
- 128项ROB ->投机


```c++
#include <math>
int main () {
  printf("a cat meow：love\n");
}
```
